%{
#include <stdio.h>
#include <stdlib.h>
int vars[26];
%}


Start           =  Spacing Expression* Spacing {
                      puts("got new programm running!");
                   }

Expression      = MethodDef
                  | ClassMethodDef
                  | MethodCall
                  | Assignment
                  | Literal
                  | Subexpression

Subexpression   = ( "(" WS* subexpr:Expression WS* ")" ) {
                    puts("Subexpression");
                  }

MethodDef       = ( Spacing "def" WS+ method_name:Identifier )
                  method_args:MethodArgs?
                  method_body:Block {
                    puts("MethodDef");
                  }

ClassMethodDef = ( Spacing "def" WS+ class_name:Identifier WS+ )
                 method_name:Identifier WS+ method_args:MethodArgs?
                 method_body:Block {
                    puts("ClassMethodDef");
                 }

MethodArgs      = ( ( arg_key:Identifier ":" WS+
                      arg_name:Identifier )+ WS* )? {
                    puts("MethodArgs");
                 }

MethodCall      = ( receiver:MessageReceiver WS+
                  ( MessageWithParams | MessageNoParams )+ ) {
                    puts("MethodCall");
                 }

MessageReceiver = ( ( Literal | Identifier ) | Subexpression ) {
                    puts("MessageReceiver");
                 }

MessageNoParams = message_name:Identifier {
                    puts("MessageNoParams");
                 }
MessageWithParams = ( message_key:Identifier ":" WS+ message_arg:Expression )+  {
                    puts("MessageWithParams");
                 }

Assignment      = ( target:Identifier WS+ "=" WS+ value:Expression ) {
                    puts("Assignment");
                 }

Literal         = StringLiteral
                  | SymbolLiteral
                  | DoubleLiteral
                  | IntLiteral
                  | CharLiteral
                  | ArrayLiteral
                  | HashLiteral
                  | BlockLiteral
                  | RegexLiteral

StringLiteral   = ( "\"" string_val:StringChars "\"" ) {
                    puts("StringLiteral");
                 }
StringChars     = !"\"" .*

SymbolLiteral   = ( ":" ( !":" symbol_name:Identifier ) ) {
                    puts("SymbolLiteral");
                 }

DoubleLiteral   = ( Sign? Digit+ "." Digit+ ) {
                    puts("DoubleLiteral");
                 }

IntLiteral      = ( Sign? NonZeroDigit Digit+ ) {
                    puts("IntLiteral");
                 }

CharLiteral     = ( "?" char:Character ) {
                    puts("CharLiteral");
                 }

ArrayLiteral    = ( "[" WS* first_item:Expression? WS* 
                          ( "," WS* item:Expression )* 
                      WS*
                  "]" ) {
                    puts("ArrayLiteral");
                 }

HashLiteral     = ( "<[" WS* first_entry:HashEntry WS*
                          ( "," WS* pair:HashEntry )*
                       WS*
                  "]>" ) {
                    puts("HashLiteral");
                 }

HashEntry       = key:Expression WS* "=>" value:Expression

BlockLiteral    = ( BlockParams? WS* Block ) {
                    puts("BlockLiteral");
                 }

RegexLiteral    = ( "/" (!"/" .)* "/" ) {
                    puts("RegexLiteral");
                 }

Block           = LCurly Expression* RCurly
BlockParams     = "|" WS* arg:Identifier ( WS* "," WS* arg:Identifier )* WS* "|"

Character       = [a-zA-Z0-9_]
Sign            = ( "+" | "-" )
Digit           = [0-9]
NonZeroDigit    = [1-9]
Identifier      = [a-zA-Z]+ [a-zA-Z0-9_]* ("?" | "!" | "=")?
LCurly          = "{"
RCurly          = "}"
Spacing         =  ( WS | Comment )*
Comment         = '#' ( !EOL . )* EOL
WS              = ' ' | '\t' | EOL
EOL             = '\r\n' | '\n' | '\r'
EOF             = !.

%%
int main(int argc, char **argv) {
  if ((argc > 1) && (freopen(argv[1], "r", stdin) == NULL))
  {
    fprintf(stderr, "%s: File %s cannot be opened.\n", argv[0], argv[1]);
    exit(1);
  }
  yyparse();
  return 0;      
}
